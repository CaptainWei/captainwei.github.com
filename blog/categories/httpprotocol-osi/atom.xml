<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Httpprotocol,OSI | Leo]]></title>
  <link href="http://CaptainWei.github.io/blog/categories/httpprotocol-osi/atom.xml" rel="self"/>
  <link href="http://CaptainWei.github.io/"/>
  <updated>2014-03-07T14:20:03+08:00</updated>
  <id>http://CaptainWei.github.io/</id>
  <author>
    <name><![CDATA[Liu Wei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Http协议<一>―OSI大局观来掌控]]></title>
    <link href="http://CaptainWei.github.io/blog/2014/01/07/httpprotocol-osi/"/>
    <updated>2014-01-07T00:54:53+08:00</updated>
    <id>http://CaptainWei.github.io/blog/2014/01/07/httpprotocol-osi</id>
    <content type="html"><![CDATA[<p>说起<em>OSI</em>，不由得想起了大学时候的教计算机网络的老师，如果没有没有记错，应该是石坚石教授，第一次上课，我就根据他的外形给他取了一个很配的名号――「金刚狼」。对于一个本科是EE的学生来说，那期间学的课程基本上都是跟数学相关，作为学渣的我，也当然一直没有明白数学与通信之间的关系&hellip;回过来说说石教授教的《计算机网络》这门课，虽然这是一门专业选修课，但应该是我大学里面上的最认真的一门课了，还有一门应该是《数字逻辑电路》，究其原因，应该是我会对自己感兴趣的东西投入相对多的精力(所以说我当初就应该是进CS，而不是EE)。</p>

<p><em>Http</em>协议虽然说是一个应用层协议，一般只要知道有这个东西就行了。但对于一个真正喜欢琢磨的人来说，这是远远不够的。正如现在绝大多数面向对象程序语言一样，都讲究的是抽象、封装，上层不用知道下层是做什么的，怎么实现的。当然，这对于一个刚入门的新手来说，这是很好的。因为你就不用花费大量时间学学习太多东西，往往看些API就行了，可以让你很快的融入团队开发。但是当你碰到一些问题的时候，你往往解决问题的方法就是试探行的，先试试这样能不能解决，再试试那样能不能解决。但是当你对这些东西的底层足够了解的时候，你解决问题也就能精准定位了，同时能知道怎么提高软件工作效率。我管后一种人叫做――<em>Cooker</em>。</p>

<p>先来说说<em>OSI</em>相关概念，可能我也不能很好的说明一些东西，如果碰到疑惑，还望大家多在网络上查找相关知识。</p>

<p><em>OSI</em>模型，即开放式通信系统互联参考模型（Open System Interconnection Reference Model）。建议看看<em>wikipedia</em>中的一些基础介绍<a href="http://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>。</p>

<p>虽然说官方文档上介绍OSI是七层模型，依次为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层，但是我们实际在使用的时候，一般是当做四层来理解，因为有些层实际使用中是可以合在一起的，所以四层自顶向下依次为应用层、运输层、网络层、链路层。这之间的信息交互如下图：
<img src="/images/HttpProtocol_OSI/Http1-1.png" alt="" /></p>

<center>图1-1</center>


<p>如图1-1所示，下层细节对上层来说是屏蔽的。例如：</p>

<blockquote><p>int socket(int domain, int type, int protocol) <br/>
int connect(int sockfd, int sockaddr<em> server_addr, socket_t addrlen) <br/>
ssize_t read(int fd, void </em>buf, size_t count) <br/>
ssize_t write(int fd, const void *buf, size_t count)</p></blockquote>

<p>socket在网络编程中是创建一个端点，为套接字返回一个文件描述符。这符合<em>UNIX</em>设计中<code>一切皆文件</code>的思想，实际上的通信相当于服务器端的<em>socket</em>和客户端的<em>socket</em>来进行通信，在创建socket的时候，会通过<em>domain、type、protocol</em>来选择创建的协议类型，<em>connect</em>相当于针对已有协议来创建连接。</p>

<p>当然，这里并不是说<em>socket()、connect()</em>函数就是对应于哪一层协议，可以把<em>socket()</em>创建的套接字当成是应用层和运输层之间的一个抽象接口，你可以理解为当<em>socket()</em>创建套接字后，当你在应用层使用这个<em>socket</em>，当使用<em>write()</em>函数时，此时注意<em>UNIX</em>中<code>一切皆文件</code>的思想，将<em>socket()</em>创建的<em>fd</em>用于<em>write</em>函数,此时就相当于操作文件来操作网络了，同时你并不需要知道它是如何实现的。<em>socket</em>对应的抽象接口如下图：
<img src="/images/HttpProtocol_OSI/Http1-2.png" alt="" /></p>

<center>图1-2</center>


<p>图1-2参见《Unix网络编程(卷1)》，其中解释到：</p>

<blockquote><p>图1-2中<em>TCP</em>与<em>UDP</em>之间留有见习，表明网络应用绕过传输层直接使用<em>IPv4</em>
或<em>IPv6</em>是可能的。这就是所谓的原始套接字(<em>row socket</em>)。</p></blockquote>

<p>当我们绕回图1-1来看HTTP协议的时候，可以将<a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">Http协议</a>当成是一种需求说明，当你使用<em>socket()</em>来创建HTTP协议<em>socket</em>后，你发送的数据中就会包含有协议中规定要求的一些东西，比如说<em>HTTP</em>协议头的一些东西，而你只需要向这个<em>socket</em>里面塞数据就行了。<em>HTTP</em>协议介绍完后，我考虑写一篇从内核角度来分析<em>socket()</em>系列的文章出来。</p>

<p>下面，我将用<em>wireshark</em>这款软件，来分析一下数据包。如果需要下载该软件，可以<em>google</em>一些，网上资源很多。</p>

<p>首先我们来探讨一下关于数据封装的基本规则，<em>http</em>协议是基于<em>TCP</em>的：
<img src="/images/HttpProtocol_OSI/Http1-3.png" alt="" /></p>

<center>图1-3</center>


<p>图1-3选自《TCP/IP详解(卷1)》，上图详细说明了各个层数据报的封装关系。下面将使用wireshark来分析各个数据包，这里就不会详细涉及<em>TCP</em>协议的三次握手行为。</p>

<p><img src="/images/HttpProtocol_OSI/Http1-4.png" alt="" /></p>

<center>图1-4</center>


<p>图1-4中红框中的内容代表TCP的三次握手行为，请求的网站是<a href="http://captainwei.github.io/blog/archives/">我的博客</a>，当服务器端收到确认报文<em>ACK</em>后，客户端便向服务器发送<em>Get</em>请求，如图，发送的是<em>GET /blog/archives/ HTTP/1.1</em>，服务器根据请求内容返回相应内容，当然，这些内容都是变成二进制，然后切割成对于大小的数据包，再进行封装，变成相应的数据报在网络中交流。其中包括一些<em>Http</em>报文格式，这个放在接下来章节说明。当然，发送的<em>http</em>请求肯定不止一个，因为一个网站包括<em>css、js</em>等各种资源，所以请求会发送几次，如下图。
<img src="/images/HttpProtocol_OSI/Http1-5.png" alt="" /></p>

<center>图1-5</center>


<p>我们现在主要看下各个报文头部对于的内容，对应于图1-3。我只找一个数据报文来看，其余的除了用户数据不同，其他头部都相同。
<img src="/images/HttpProtocol_OSI/Http1-6.png" alt="" /></p>

<center>图1-6</center>


<p>其中黄色框中代表我选取的一个数据报，数据报大小为1514kb。我们通过图1-3知道，以太网首部对应应该是14<em>bytes</em>，现在我们看一下对应的以太网首部。中间的蓝色部分我们可以看到：</p>

<blockquote><p>Src: Hangzhou_a8:dc:bd (3c:e5:a6:a8:dc:bd) <br/>
Dst: Elitegro_21:16:b9 (c8:9c:dc:21:16:b9)</p></blockquote>

<p>Src代表服务器的物理地址 (3c:e5:a6:a8:dc:bd)，Dst代表我本机物理地址(c8:9c:dc:21:16:b9)，这两个地址就占用了12<em>bytes</em>，在对于的0000那行中依次显示出来，这占用了12<em>bytes</em>，还剩下来2<em>bytes</em>为08 00。这其实一个类型解释码，告诉我们接下来的是IP数据报。对于的类型解释如下：</p>

<blockquote><p>08 00 ： IP数据报 <br/>
08 06 ： ARP请求/应答 <br/>
o8 35 ： RARP请求/应答</p></blockquote>

<p>如果还想知道更具体的内容，请看《TCP/IP详解(卷1)》中的第二章。现在来看IP数据报首部，如下：
<img src="/images/HttpProtocol_OSI/Http1-7.png" alt="" /></p>

<center>图1-7</center>


<p>Ip数据报首部有20<em>bytes</em>，具体字节含义，请看《TCP/IP详解(卷1)》中的第三章。其中最后8<em>bytes</em>中含有源<em>IP</em>地址、目的<em>IP</em>地址，两者分别占4<em>bytes</em>。我们可以自己将103.245.222.133转换为十六进制，结果是：67 f5 de 85, 目的<em>IP</em>10.2.132.59转换为十六进制，结果是：0a 02 84 3b。恰好跟图中0010 0020 两行最后8<em>bytes</em>对应上。</p>

<p>再来看看TCP首部数据报，也是20<em>bytes</em>，具体字节含义，请看《TCP/IP详解(卷1)》中的第十七章。其中，最主要的前4<em>bytes</em>分别代表源端口号和目的端口号。如下图：</p>

<p><img src="/images/HttpProtocol_OSI/Http1-8.png" alt="" /></p>

<center>图1-8</center>


<p>服务器上的端口用的是80，对应的十六进制为00 50；目的端口是我本地浏览器上与之对应的端口40975，对应的十六进制为a0 0f，恰好跟0200行前4<em>bytes</em>对应上。当然，不是所有网页对应的本地服务器都是40975这个端口，首先，这个端口是每次建立socket连接是，随机分配的端口，其次，每个不同的网页，例如<em>google</em>，你可以当他是一个新的应用程序，所以用的是另外分配的一个随机端口，这样，从而与服务器的信息交互，通过<em>ip</em>到达我们本地计算机后，能根据端口来进行正确的数据处理。</p>

<p>最后，就是用户数据报部分了，详情如下：
<img src="/images/HttpProtocol_OSI/Http1-9.png" alt="" /></p>

<center>图1-9</center>


<p>图中包括了<em>Http</em>报头部分以及网页数据，我选取的这个数据报，恰好包含了网页最开始的一部分数据，这是因为很多网页数据是不可能在（1514-14-20-20）=1460<em>bytes</em>中传过来的。我选取的这部分包括了<code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;</code>等，<em>Http</em>报头详解，我将放在下面几章来介绍。</p>

<p>目前，基于<em>OSI</em>模型的<em>Http</em>协议分析就写完了，后面我将来具体分析<em>Http</em>协议。如有错误欢迎指正，如果认为内容还可以，请点个赞吧。</p>

<h2>PS:转载请保留出处,毕竟花费了很多时间</h2>
]]></content>
  </entry>
  
</feed>
